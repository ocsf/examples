

root.category_uid = 1
root.category_name = "System Activity"
root.class_uid = 1002
root.class_name = "Kernel Extension Activity"
root.activity_name = "Load"
root.activity_id = 1
#root.type_name = "Kernel Extension Activity: Load"
root.time = this.winlog.event_data.UtcTime.ts_strptime("%Y-%m-%d %H:%M:%S.%f").ts_unix_milli()
root.time_dt = this.winlog.event_data.UtcTime
root.message = this.winlog.task
root.severity_id = 1
root.severity = "Informational"
root.status_id = 1
root.disposition_id = 17
root.disposition = "Logged"

root.metadata.profiles = ["host","security_control","datetime"]
root.metadata.event_code = this.winlog.event_id
root.metadata.uid = this.winlog.record_id.string()
root.metadata.logged_time = this.event.created.ts_unix_milli()
root.metadata.logged_time_dt = this.event.created
root.metadata.log_name = this.winlog.channel
root.metadata.log_provider = this.winlog.provider_name
root.metadata.product.lang = "EN"
root.metadata.product.name = "Sysmon"
root.metadata.product.vendor_name = "Sysmon"
root.metadata.version = "1.0.0"
root.metadata.original_time = this.winlog.event_data.UtcTime

root.device.type = "Server"
root.device.type_id = 1
root.device.hostname = this.winlog.computer_name.split(".").index(0)
root.device.os.type_id = 100
root.device.os.type = "Windows"
root.device.os.name = "Microsoft Windows"

root.attacks = [{
    "version": "v13",
    "technique": {
        "name" : this.mitre.technique_name,
        "uid" : this.mitre.technique_id},
    "tactics" : [],
}]

root.actor.process.file.name = winlog.event_data.ImageLoaded.split("\\").index(-1)

root.driver.file.company_name = this.winlog.event_data.Signature
root.driver.file.name = this.winlog.event_data.ImageLoaded.split("\\").index(-1)
root.driver.file.path = this.winlog.event_data.ImageLoaded
root.driver.file.type_id = match {
    this.winlog.event_data.ImageLoaded.contains(".sys") => 99
    _=> 2
}
root.driver.file.type = match {
    this.winlog.event_data.ImageLoaded.contains(".sys") => "Driver"
    _=> "Other"
}
root.driver.file.hashes = if this.winlog.event_data.exists("Hash") {this.winlog.event_data.Hash.key_values().map_each(item -> {
    "algorithm_id": match {
        item.key == "MD5" => 1,
        item.key == "SHA1" => 2,
        item.key == "SHA256" => 3,
        item.key == "IMPHASH" => 99,
    },
    "algorithm": match {
        item.key == "MD5" => "MD5",
        item.key == "SHA1" => "SHA-1",
        item.key == "SHA256" => "SHA-256",
        item.key == "IMPHASH" => "IMPHASH"
    },
    "value": item.value.string()}) } else {deleted()}

root.type_uid = root.class_uid.number() * 100 + root.activity_id.number()
root.unmapped = this.without(
    "winlog.event_data.UtcTime",
    "winlog.task",
    "winlog.event_id",
    "winlog.record_id",
    "event.created",
    "winlog.channel",
    "winlog.provider_name",
    "winlog.computer_name",
    "winlog.event_data.ImageLoaded",
    "winlog.event_data.Hash",
    "mitre",
    "winlog.event_data.Signature"
)
let myhash = root.driver.file.hashes.map_each(hash -> hash.value).collapse()

observables = root.without("unmapped").with("file.name", "device.hostname").merge($myhash).(item -> {
   "a": match {item.device.exists("hostname") => {"name": "device.hostname", "type": "Hostname", "type_id": 1, "value": item.device.hostname}},
   "b": match {item.file.exists("name") => {"name": "file.name", "type": "File Name", "type_id": 7, "value": item.file.name}},
   "c": match {item.exists("0") => {"name": "driver.file.hashes.value", "type": "File Hash", "type_id": 8, "value": item.0}},
   "d": match {item.exists("1") => {"name": "driver.file.hashes.value", "type": "File Hash", "type_id": 8, "value": item.1}},
   "e": match {item.exists("2") => {"name": "driver.file.hashes.value", "type": "File Hash", "type_id": 8, "value": item.2}},
   "f": match {item.exists("3") => {"name": "driver.file.hashes.value", "type": "File Hash", "type_id": 8, "value": item.3}},
   "g": match {item.exists("4") => {"name": "driver.file.hashes.value", "type": "File Hash", "type_id": 8, "value": item.4}},
   }).values()